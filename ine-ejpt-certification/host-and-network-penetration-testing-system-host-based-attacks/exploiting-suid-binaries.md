# Exploiting SUID Binaries

* In addition to the three main file access permissions (read, write and execute), Linux also provides users with specialized permissions that can be utilized in specific situations. One of these access permissions is the <mark style="color:red;">SUID (Set Owner User ID)</mark> permission.
* When applied, this permission provides users with the ability to execute a script or binary <mark style="color:orange;">with the permissions of the file owner</mark> as <mark style="color:orange;">opposed to the user that is running the script or binary</mark>.
* SUID permissions are typically used to provide unprivileged users with the ability to run specific scripts or binaries with "root" permissions. It is to be noted, however, that the provision of elevate privileges is limited to the execution of the script and does not translate to elevation of privileges, however, if improperly configured unprivileged users can exploit misconfigurations or vulnerabilities within the binary or script to obtain an elevated session.
* This is the functionality that we will be attempting to exploit in order to elevate our privileges, hoever, the success of our attack <mark style="color:blue;">will depend on the following factors:</mark>
  * <mark style="color:red;">Owner of the SUID binary</mark> - Given that we are attempting to elevate our privileges, we will only be exploiting SUID binaries that are owned by the "root" user or other privileged users.
  * <mark style="color:red;">Access permissions</mark> - We will require executable permissions in order to execute the SUID binary.

## Practice Demo

We already have initial access with an unprivileged account.

We have two a binary in our home directory called "welcome" that is owned by root user and has the SUID permission.

<figure><img src="../../.gitbook/assets/image (199).png" alt=""><figcaption></figcaption></figure>

To get more info about a file, in this case "welcome" run:

* <mark style="color:yellow;">file welcome</mark>

<figure><img src="../../.gitbook/assets/image (200).png" alt=""><figcaption></figcaption></figure>

To identify strings in a binary:

* <mark style="color:yellow;">strings welcome</mark>

In this case, the "<mark style="color:red;">welcome"</mark> binary is calling the "greetings" binary. So since we can't write to the "<mark style="color:red;">greetings</mark>" binary, we can delete it and create a new one with our malicious code.

* <mark style="color:yellow;">rm greetings</mark>

Creating our greetings binary:

* <mark style="color:yellow;">cp /bin/bash greetings</mark>

Now by executing the "<mark style="color:red;">welcome</mark>" binary, which calls the "<mark style="color:red;">greetings</mark>" binary we created, we get a <mark style="color:red;">root shell</mark> because the "greetings" binary is owned by root.

<figure><img src="../../.gitbook/assets/image (201).png" alt=""><figcaption></figcaption></figure>
